#!/usr/bin/env python3
from __future__ import annotations

import os
import sys
import json
import subprocess
from pathlib import Path
from datetime import datetime, timezone

import pandas as pd
import numpy as np


# -----------------------------
# Paths (adjust if needed)
# -----------------------------
MYTRADING_DIR = Path.home() / "github" / "myTrading"
JOB_DIR = Path.home() / "github" / "jobMyTrading"

OUT_CSV = JOB_DIR / "crypto_signals.csv"
OUT_HTML = JOB_DIR / "crypto_signals.html"
OUT_README = JOB_DIR / "README.md"
OUT_META = JOB_DIR / "meta.json"

LOG_FILE = JOB_DIR / "job.log"


def log(msg: str):
    ts = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")
    line = f"[{ts}] {msg}\n"
    print(line, end="")
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8") as f:
            f.write(line)
    except Exception:
        pass


def run_cmd(cmd: list[str], cwd: Path | None = None) -> tuple[int, str]:
    p = subprocess.run(
        cmd,
        cwd=str(cwd) if cwd else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )
    return p.returncode, p.stdout


def git_has_changes(repo_dir: Path) -> bool:
    code, out = run_cmd(["git", "status", "--porcelain"], cwd=repo_dir)
    if code != 0:
        raise RuntimeError(f"git status failed:\n{out}")
    return out.strip() != ""


def safe_to_float(x, default=0.0) -> float:
    try:
        return float(pd.to_numeric(x, errors="coerce"))
    except Exception:
        return float(default)


def build_html_table(df: pd.DataFrame, title: str, updated_utc: str) -> str:
    # keep it readable on GitHub
    # We wonâ€™t depend on external CSS.
    html = []
    html.append("<!doctype html><html><head><meta charset='utf-8'>")
    html.append(f"<title>{title}</title>")
    html.append("<style>")
    html.append("""
        body { font-family: Arial, sans-serif; margin: 16px; }
        h2 { margin-bottom: 6px; }
        .meta { color: #666; margin-bottom: 12px; }
        table { border-collapse: collapse; width: 100%; font-size: 14px; }
        th, td { border: 1px solid #ddd; padding: 6px 8px; }
        th { background: #f5f5f5; text-align: left; position: sticky; top: 0; }
        tr:nth-child(even) { background: #fafafa; }
        .red { color: #c00; font-weight: 700; }
        .num { text-align: right; font-variant-numeric: tabular-nums; }
        .small { font-size: 12px; color: #666; }
    """)
    html.append("</style></head><body>")
    html.append(f"<h2>{title}</h2>")
    html.append(f"<div class='meta'>Last updated: <b>{updated_utc}</b></div>")

    # format numeric columns nicely
    df2 = df.copy()

    for c in df2.columns:
        if c in ("ALT USD Val", "USDC Value", "Total Val"):
            df2[c] = pd.to_numeric(df2[c], errors="coerce").fillna(0.0).map(lambda v: f"${v:,.2f}")
        if c in ("ALT%",):
            df2[c] = pd.to_numeric(df2[c], errors="coerce").fillna(0.0).map(lambda v: f"{v:.2f}%")
        if c in ("Qty", "QTY"):
            df2[c] = pd.to_numeric(df2[c], errors="coerce").fillna(0.0).map(lambda v: f"{v:,.6f}".rstrip("0").rstrip("."))

    # add simple class for ACTION rows
    def row_class(r):
        a = str(r.get("ACTION", ""))
        return " class='red'" if a.startswith("ðŸ”´") else ""

    # manual render so ACTION can be colored
    cols = list(df2.columns)
    html.append("<table>")
    html.append("<thead><tr>")
    for c in cols:
        html.append(f"<th>{c}</th>")
    html.append("</tr></thead><tbody>")

    for _, r in df2.iterrows():
        klass = row_class(r)
        html.append(f"<tr{klass}>")
        for c in cols:
            v = r.get(c, "")
            # right-align numbers a bit
            if c in ("ALT USD Val", "USDC Value", "Total Val", "ALT%", "Qty", "QTY"):
                html.append(f"<td class='num'>{v}</td>")
            else:
                html.append(f"<td>{v}</td>")
        html.append("</tr>")
    html.append("</tbody></table>")

    html.append("<div class='small'>Generated by Raspberry Pi hourly job.</div>")
    html.append("</body></html>")
    return "\n".join(html)


def main():
    # Make sure we can import myTrading modules
    if str(MYTRADING_DIR) not in sys.path:
        sys.path.insert(0, str(MYTRADING_DIR))

    # Imports from your existing myTrading code
    from data.crypto import (
        build_crypto_signals_table,
        enrich_crypto_portfolio_fields,
        fetch_coingecko_global,
        fetch_total_mcap_history_coingecko,
        fetch_total_mcap_history_coinmarketcap,
        compute_total_vs_200ma,
        fetch_altcoin_season_index,
    )

    # Load config lists from myTrading/app.py style:
    # Weâ€™ll read asset_registry + use hard-coded tickers if you want,
    # but easiest: import from app.py if present.
    try:
        import importlib.util
        spec = importlib.util.spec_from_file_location("myTrading_app", str(MYTRADING_DIR / "app.py"))
        mod = importlib.util.module_from_spec(spec)
        assert spec and spec.loader
        spec.loader.exec_module(mod)
        CRYPTO_TICKERS = getattr(mod, "CRYPTO_TICKERS")
        CRYPTO_NOT_FOUND_YAHOO = getattr(mod, "CRYPTO_NOT_FOUND_YAHOO", {})
        # indicator params
        ATR_PERIOD = getattr(mod, "ATR_PERIOD", 10)
        ATR_MULTIPLIER = getattr(mod, "ATR_MULTIPLIER", 3.0)
        RSI_PERIOD = getattr(mod, "RSI_PERIOD", 14)
        VOL_LOOKBACK = getattr(mod, "VOL_LOOKBACK", 20)
        VOL_MULTIPLIER = getattr(mod, "VOL_MULTIPLIER", 1.2)
        RSI_BUY_THRESHOLD = getattr(mod, "RSI_BUY_THRESHOLD", 50.0)
        ADXR_LEN = getattr(mod, "ADXR_LEN", 14)
        ADXR_LENX = getattr(mod, "ADXR_LENX", 14)
        ADXR_LOW_THRESHOLD = getattr(mod, "ADXR_LOW_THRESHOLD", 20.0)
        ADXR_FLAT_EPS = getattr(mod, "ADXR_FLAT_EPS", 1e-6)
    except Exception as e:
        raise RuntimeError(f"Could not import config from myTrading/app.py: {e}")

    updated_utc = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    log("Job start: building crypto signals table...")

    df_crypto = build_crypto_signals_table(
        CRYPTO_TICKERS,
        gecko_pools=CRYPTO_NOT_FOUND_YAHOO,
        atr_period=ATR_PERIOD,
        atr_multiplier=ATR_MULTIPLIER,
        rsi_period=RSI_PERIOD,
        vol_lookback=VOL_LOOKBACK,
        vol_multiplier=VOL_MULTIPLIER,
        rsi_buy_threshold=RSI_BUY_THRESHOLD,
        adxr_len=ADXR_LEN,
        adxr_lenx=ADXR_LENX,
        adxr_low_threshold=ADXR_LOW_THRESHOLD,
        adxr_flat_eps=ADXR_FLAT_EPS,
    )

    log("Enriching with wallet balances/portfolio fields (can be slow)...")
    df_crypto = enrich_crypto_portfolio_fields(df_crypto)

    # ---------------------------
    # Match your Streamlit logic:
    # ALT USD Val + USDC Value + Total Val + ALT% + ACTION
    # ---------------------------
    if "USD Value" in df_crypto.columns:
        df_crypto = df_crypto.rename(columns={"USD Value": "ALT USD Val"})

    for c in ["ALT USD Val", "USDC Value"]:
        if c in df_crypto.columns:
            df_crypto[c] = pd.to_numeric(df_crypto[c], errors="coerce").fillna(0.0)

    if "ALT USD Val" not in df_crypto.columns:
        df_crypto["ALT USD Val"] = 0.0
    if "USDC Value" not in df_crypto.columns:
        df_crypto["USDC Value"] = 0.0

    df_crypto["Total Val"] = df_crypto["ALT USD Val"] + df_crypto["USDC Value"]
    df_crypto["ALT%"] = np.where(
        df_crypto["Total Val"] > 0,
        (df_crypto["ALT USD Val"] / df_crypto["Total Val"]) * 100.0,
        0.0,
    ).round(2)

    SIGNAL_COL = "SIGNAL-Super-MOST-ADXR"

    def _action_row(r):
        sig = str(r.get(SIGNAL_COL, "")).upper()
        alt_pct = float(pd.to_numeric(r.get("ALT%", 0.0), errors="coerce") or 0.0)
        if sig == "BUY" and alt_pct < 50.0:
            return "ðŸ”´ BUY ALT"
        if sig == "EXIT" and alt_pct > 50.0:
            return "ðŸ”´ SELL ALT"
        return ""

    df_crypto["ACTION"] = df_crypto.apply(_action_row, axis=1)

    # Reorder columns similar to Streamlit
    cols = list(df_crypto.columns)

    def move_after(col_to_move, after_col):
        nonlocal cols
        if col_to_move in cols and after_col in cols:
            cols.remove(col_to_move)
            idx = cols.index(after_col) + 1
            cols.insert(idx, col_to_move)

    move_after("ACTION", SIGNAL_COL)
    move_after("ALT%", "ALT USD Val")
    move_after("Total Val", "USDC Value")

    df_crypto = df_crypto[cols]

    # Sort by Total Val desc if exists
    if "Total Val" in df_crypto.columns:
        df_crypto = df_crypto.sort_values("Total Val", ascending=False)

    # Totals
    alt_total = float(pd.to_numeric(df_crypto["ALT USD Val"], errors="coerce").fillna(0.0).sum())
    usdc_total = float(pd.to_numeric(df_crypto["USDC Value"], errors="coerce").fillna(0.0).sum())
    grand_total = float(pd.to_numeric(df_crypto["Total Val"], errors="coerce").fillna(0.0).sum())
    alt_pct_total = (alt_total / grand_total * 100.0) if grand_total > 0 else 0.0

    # Crypto context (optional metadata)
    meta = {
        "updated_at_utc": updated_utc,
        "totals": {
            "alt_total_usd": alt_total,
            "usdc_total_usd": usdc_total,
            "grand_total_usd": grand_total,
            "alt_pct_total": alt_pct_total,
        },
        "context": {},
    }

    try:
        cg = fetch_coingecko_global()
        meta["context"]["coingecko_global"] = cg
    except Exception as e:
        meta["context"]["coingecko_global_error"] = str(e)

    try:
        total_hist = None
        try:
            total_hist = fetch_total_mcap_history_coingecko(days=900)
            if not isinstance(total_hist, pd.DataFrame):
                raise ValueError("CoinGecko history not dataframe")
        except Exception:
            total_hist = fetch_total_mcap_history_coinmarketcap(days=900)
        meta["context"]["total_vs_200ma"] = compute_total_vs_200ma(total_hist)
    except Exception as e:
        meta["context"]["total_vs_200ma_error"] = str(e)

    try:
        meta["context"]["altcoin_season"] = fetch_altcoin_season_index()
    except Exception as e:
        meta["context"]["altcoin_season_error"] = str(e)

    # Write outputs
    JOB_DIR.mkdir(parents=True, exist_ok=True)
    df_crypto.to_csv(OUT_CSV, index=False)

    html = build_html_table(
        df_crypto,
        title="Crypto 4H Signals + Wallet Balances",
        updated_utc=updated_utc,
    )
    OUT_HTML.write_text(html, encoding="utf-8")

    readme = f"""# Crypto Signals Snapshot

Last updated: **{updated_utc}**

## Totals
- **Total ALT USD Val:** ${alt_total:,.2f}
- **Total USDC Value:** ${usdc_total:,.2f}
- **Grand Total (ALT + USDC):** ${grand_total:,.2f}
- **Total ALT %:** {alt_pct_total:.2f}%

## Table
Open **crypto_signals.html** in the repo for the formatted table.

(Generated hourly from Raspberry Pi.)
"""
    OUT_README.write_text(readme, encoding="utf-8")
    OUT_META.write_text(json.dumps(meta, indent=2), encoding="utf-8")

    log("Outputs written: csv/html/readme/meta")

    # Git commit & push if changed
    code, _ = run_cmd(["git", "rev-parse", "--is-inside-work-tree"], cwd=JOB_DIR)
    if code != 0:
        log("jobMyTrading is not a git repo (skipping push).")
        return

    if not git_has_changes(JOB_DIR):
        log("No changes detected (skipping commit/push).")
        return

    run_cmd(["git", "add", "-A"], cwd=JOB_DIR)
    msg = f"Hourly crypto snapshot: {updated_utc}"
    code, out = run_cmd(["git", "commit", "-m", msg], cwd=JOB_DIR)
    if code != 0:
        log(f"git commit failed:\n{out}")
        return

    code, out = run_cmd(["git", "push", "origin", "main"], cwd=JOB_DIR)
    if code != 0:
        log(f"git push failed:\n{out}")
        return

    log("Pushed to GitHub âœ…")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        log(f"FATAL: {repr(e)}")
        raise

